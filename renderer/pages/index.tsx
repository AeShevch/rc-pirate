import Head from "next/head";
import styles from "@/renderer/styles/Home.module.css";
import { Card, Space, Alert, Form, Input, Button } from "antd";
import React from "react";
import axios from "axios";
// import { FilesUploadQueuesResponsePayload } from "@/renderer/pages/api/parser/files/getUploadQueues";
import { Nullable } from "@/main/utils/types";
import electron from "electron";
import { IPCChannel } from "@/main/const";
import {
  FilesUploadQueuesResponsePayload,
  FileToCDNUpload,
  ParserResponsePayload,
  ParserUserInput,
} from "@/main/services/ParserService";

const ipcRenderer = electron.ipcRenderer || false;

export default function Home() {
  const [form] = Form.useForm<ParserUserInput>();
  const [isLoading, setIsLoading] = React.useState<boolean>(false);
  const [isEnd, setIsEnd] = React.useState<boolean>(false);
  const [errorMessage, setErrorMessage] =
    React.useState<Nullable<string>>(null);
  const [successMessage, setSuccessMessage] =
    React.useState<Nullable<string>>(null);
  const [loadingButtonText, setLoadingButtonText] = React.useState<string>(``);
  const [resultFolderTimestamp, setResultFolderTimestamp] =
    React.useState<Nullable<string>>(null);

  const resetState = (): void => {
    setErrorMessage(null);
    setSuccessMessage(null);
    setIsEnd(false);
    setIsLoading(false);
    setResultFolderTimestamp(null);
  };

  const fetchParseRichContent = async ({
    url,
    containerSelector,
  }: ParserUserInput): Promise<ParserResponsePayload | void> => {
    try {
      const { data } = await axios.get<ParserResponsePayload>(
        `/api/parser/parse?url=${url}&containerSelector=${containerSelector}`
      );

      return data;
    } catch (err) {
      if (axios.isAxiosError(err)) {
        setErrorMessage(err.message);
      } else {
        console.log("unexpected err: ", err);
        setErrorMessage(`ü¶ú –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞! –ü–æ–∑–≤–∞—Ç—å —Ä–∞–∑—Ä–∞–±–∞ –Ω–∞ –º–æ—Å—Ç–∏–∫!`);
      }
      setIsLoading(false);
    }
  };

  const fetchUploadParsedFilesToCDN = async (
    filesToUpload: FileToCDNUpload[]
  ): Promise<void> => {
    try {
      await axios.get<void>(
        `/api/parser/files/cdnUpload?files=${JSON.stringify(filesToUpload)}`
      );
    } catch (err) {
      if (axios.isAxiosError(err)) {
        setErrorMessage(err.message);
      } else {
        console.log("unexpected err: ", err);
        setErrorMessage(`ü¶ú –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞! –ü–æ–∑–≤–∞—Ç—å —Ä–∞–∑—Ä–∞–±–∞ –Ω–∞ –º–æ—Å—Ç–∏–∫!`);
      }
      setIsLoading(false);
    }
  };

  React.useEffect(() => {
    if (ipcRenderer) {
      ipcRenderer.on(IPCChannel.Parse, onParserDataReceive);
      ipcRenderer.on(IPCChannel.GetUploadQueues, onUploadQueuesReceive);

      return () => {
        ipcRenderer.removeAllListeners(IPCChannel.Parse);
        ipcRenderer.removeAllListeners(IPCChannel.GetUploadQueues);
      };
    }
  }, []);

  const uploadToCDN = async (links: FileToCDNUpload[]): Promise<void> =>
    new Promise<void>((resolve, reject) => {
      if (ipcRenderer) {
        ipcRenderer.send(IPCChannel.UploadToCDN, links);

        ipcRenderer.on(IPCChannel.UploadToCDN, () => {
          ipcRenderer.removeAllListeners(IPCChannel.UploadToCDN);
          resolve();
        });
      } else {
        reject(`ipcRenderer is not defined!`);
      }
    });

  const onParserDataReceive = (
    evt: Electron.IpcRendererEvent,
    parserData: ParserResponsePayload
  ) => {
    if (parserData.err) {
      resetState();
      setErrorMessage(parserData.err);
      return;
    }

    setLoadingButtonText(`–ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞—é —Ñ–∞–π–ª—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ CDN...`);
    setResultFolderTimestamp(parserData.timestamp);

    if (ipcRenderer) {
      ipcRenderer.send(IPCChannel.GetUploadQueues);
    }
  };

  const onUploadQueuesReceive = async (
    evt: Electron.IpcRendererEvent,
    parserData: FilesUploadQueuesResponsePayload
  ) => {
    if (parserData && parserData.err) {
      resetState();
      setErrorMessage(parserData.err);
      return;
    }

    setLoadingButtonText(`–ó–∞–≥—Ä—É–∂–∞—é —Ñ–∞–π–ª—ã –Ω–∞ CDN...`);

    for await (const filesToUpload of parserData.filesUploadQueues) {
      await uploadToCDN(filesToUpload);
    }

    setTimeout(() => {
      setIsEnd(true);
      setSuccessMessage(`ü¶ú –ê–±–æ—Ä–¥–∞–∂ —É—Å–ø–µ—à–µ–Ω! –ß—Ç–æ –¥–∞–ª—å—à–µ, –∫–∞–ø–∏—Ç–∞–Ω?`);
      setIsLoading(false);
      setLoadingButtonText(``);
    }, 5000);
  };

  const onSubmit = async (formFields: ParserUserInput) => {
    setErrorMessage(null);
    setSuccessMessage(null);
    setIsEnd(false);
    setIsLoading(true);
    setResultFolderTimestamp(null);
    setLoadingButtonText(`–ü–∞—Ä—à—É –≤—ë—Ä—Å—Ç–∫—É –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...`);

    if (ipcRenderer) {
      ipcRenderer.send(IPCChannel.Parse, formFields);
    }
  };

  return (
    <>
      <Head>
        <title>üè¥‚Äç‚ò†Ô∏è Yo-ho-ho!</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/renderer/public/favicon.ico" />
      </Head>
      <main className={styles.main}>
        <Card
          title="üè¥‚Äç‚ò†Ô∏è Rich Content Pirate v0.9.4-beta"
          style={{ width: "40rem" }}
        >
          <Form form={form} onFinish={onSubmit} layout="vertical">
            <Space direction="vertical" size={20} style={{ width: "100%" }}>
              <Alert
                message={
                  <>
                    ¬´–†–µ–∫–≤–∏–∑–∏—Ä–æ–≤–∞—Ç—å. –ú—ã —Ä–µ–∫–≤–∏–∑–∏—Ä—É–µ–º —ç—Ç–æ—Ç —Ä–∏—á –∫–æ–Ω—Ç–µ–Ω—Ç. –≠—Ç–æ –º–æ—Ä—Å–∫–æ–π
                    —Ç–µ—Ä–º–∏–Ω¬ª <br /> ‚Äì –î–∂–µ–∫ –í–æ—Ä–æ–±–µ–π
                  </>
                }
                type="info"
              />

              <div>
                <Form.Item
                  name="url"
                  label="–°—Å—ã–ª–∫–∞ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å ¬´—Ä–µ–∫–≤–∏–∑–∏—Ä—É–µ–º—ã–º¬ª –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º"
                  hasFeedback
                  rules={[
                    { required: true },
                    { type: "url", warningOnly: true },
                    {
                      type: "string",
                      min: 6,
                    },
                  ]}
                >
                  <Input
                    disabled={isLoading}
                    placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä, https://istyle.cz/macbook-pro-14-...-stribrny.html"
                  />
                </Form.Item>
                <Form.Item
                  name="containerSelector"
                  hasFeedback
                  label="html-c–µ–ª–µ–∫—Ç–æ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ c –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º (–ù–∞ istyle.cz —ç—Ç–æ –æ–±—ã—á–Ω–æ .block-static-block)"
                  initialValue=".block-static-block"
                  rules={[{ required: true }, { type: "string" }]}
                >
                  <Input disabled={isLoading} />
                </Form.Item>
              </div>

              {!!errorMessage && <Alert message={errorMessage} type="error" />}

              <Button type="primary" htmlType="submit" loading={isLoading}>
                {!isLoading && `‚õµ –ü–æ–¥–Ω—è—Ç—å –ø–∞—Ä—É—Å–∞!`}
                {isLoading && loadingButtonText}
              </Button>

              {(successMessage || isEnd) && (
                <Space direction="vertical">
                  {!!successMessage && (
                    <Alert message={successMessage} type="success" />
                  )}

                  {!!isEnd && (
                    <>
                      <a
                        rel="noreferrer"
                        href={`https://cdn.iport.ru/rc-pirate/${resultFolderTimestamp}/html/index.html`}
                        target="_blank"
                        style={{ color: `#1677ff` }}
                      >
                        –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–µ–≤—å—é (–≤ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ)
                      </a>
                      <a
                        rel="noreferrer"
                        href={`https://cdn.iport.ru/rc-pirate/${resultFolderTimestamp}/html.zip`}
                        style={{
                          color: `#1677ff`,
                          borderBottom: `1px dashed currentColor`,
                        }}
                        download
                        target="_blank"
                      >
                        –°–∫–∞—á–∞—Ç—å –∞—Ä—Ö–∏–≤
                      </a>
                    </>
                  )}
                </Space>
              )}
            </Space>
          </Form>
        </Card>
      </main>
    </>
  );
}
